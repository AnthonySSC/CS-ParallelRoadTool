using UnityEngine;

namespace ParallelRoadTool.Extensions;

public static class Vector3Extensions
{
    /// <summary>
    ///     Given a point, a direction and a distance, we can get the coordinates for a point which is parallel to the given
    ///     one for the given direction.
    /// </summary>
    /// <param name="point"></param>
    /// <param name="direction"></param>
    /// <param name="horizontalDistance"></param>
    /// <param name="verticalDistance"></param>
    /// <param name="isClockwise"></param>
    /// <returns>A <see cref="Vector3" /> with the coordinates generated by offsetting the given point.</returns>
    public static Vector3 Offset(this Vector3 point, Vector3 direction, float horizontalDistance, float verticalDistance, bool isClockwise = true)
    {
        var offsetPoint = point + horizontalDistance * new Vector3((isClockwise ? 1 : -1)              * direction.z,
                                                                   direction.y, (isClockwise ? -1 : 1) * direction.x);
        offsetPoint.y = point.y + verticalDistance;

        return offsetPoint;
    }

    /// <summary>
    ///     Rotates the provided vector alongside the vertical axis by angle.
    /// </summary>
    /// <param name="vector"></param>
    /// <param name="angle"></param>
    /// <returns></returns>
    public static Vector3 RotateXZ(this Vector3 vector, float angle = 90)
    {
        return Quaternion.Euler(0, angle, 0) * vector;
    }

    /// <summary>
    ///     To be fair I have no idea on what this does, ported it from
    ///     <a href="https://codepen.io/brunoimbrizi/pen/VYEWgY?editors=0010">here</a>.
    ///     I guess it applies the offset to vector while also normalizing it.
    /// </summary>
    /// <param name="vector"></param>
    /// <param name="horizontalOffset"></param>
    /// <param name="verticalOffset"></param>
    /// <returns></returns>
    public static Vector3 NormalizeWithOffset(this Vector3 vector, float horizontalOffset, float verticalOffset = 0)
    {
        if (vector.magnitude <= 0) return vector;

        var offsetMagnitude = horizontalOffset / vector.magnitude;
        return vector with { x = vector.x * offsetMagnitude, y = vector.y + verticalOffset, z = vector.z * offsetMagnitude };
    }
}
